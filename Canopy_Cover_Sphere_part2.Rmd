---
title: "Canopy_Cover_Sphere_part2"
author: "Sam Ericksen"
date: '2022-04-30'
output: html_document
bibliography: references.yaml
wrap: 300
---

```{r setup, include=FALSE}
library(knitr)
options(width = 300)
```

# Estimating Canopy Cover with Spherical Photos Part 2

a wrapper for exif tools comes in the form of a package called exifr ( @mike2022 ). Exiftools and Perl must be installed already to use exifr ( @exiftool )

```{r packages, message=FALSE, warning=FALSE}
library(exifr)
library(plotKML)
library(lubridate)
library(magrittr)
library(tidyr)
library(dplyr)
library(leaflet)
library(gstat)
library(rgdal)
library(sp)
library(sf)
library(terra)
```

<https://rspatial.org/raster/analysis/4-interpolation.html>

( @interpol )

## Geometry from photos

Althought the GoPro 360 embeds GPS information in each photo, this information is about as precise as a normal phone GPS (\~5m). In order to get better accuracy, an Arrow hat-mounted GPS was unit was used to collect location information during this survey, which output a `16-Feb-2022-1600-clipped.gpx` file with higher preccision than consumer grade GPS units. In order to match the photos up with the Arrow GPS we need time stamp information from the pictures, as well as the tracks file.

### Picture information

Here we use exifr to read in metadata associated with the photos. the `args` allow us to keep only the metadata associated with those calls (i.e. we keep only the file name, the time variables, and the gps variables).

```{r get image info, message=FALSE, warning=FALSE, eval=FALSE}

image_path <- list.files("360_Pics/",
                         full.names = T) #test image

image_df <-  read_exif(image_path, 
             args = "-*FileName* -*Time* - *GPS*")
```

```{r psuedo image exif, include=FALSE}
image_df <- read.csv2("all_images_exif.csv")
```

```{r plot photo locations}
#keep time as an attribute
```

### Read GPX

This process is simple enough, we read in the `.gpx` data using the `plotKML` package ( @plotkml ). All we have to do is subset it to the dataframe containing the lat/lon and timestamp (here we do it all in one line just for convenience.

```{r gpx}
gps_pnts <- readGPX("16-Feb-2022-1600-clipped.gpx")$tracks[[1]][[1]] #get tracks from .gpx file

range(gps_pnts$time)
```

```{r plot gpx locations}
leaflet(slice(gps_pnts,which(row_number() %% 10 == 1))) %>% #display every 10th element (lots of points here)
  addProviderTiles("Esri.WorldImagery") %>% 
  addMarkers(lng = ~lon, 
             lat = ~lat, 
             popup = ~time)
# keep time as an attribute
```

### Lining up times

That's looking good, but lets make sure that the time ranges line up between the images and the `.gpx` tracks. We'll just compare the ranges to make sure they are similar.

```{r compare ranges}
print(paste("gpx time range:", 
            range(gps_pnts$time)[1], 
            "-", 
            range(gps_pnts$time)[2]))
print(paste("image time range:", 
            range(image_df$GPSDateTime)[1], 
            "-", 
            range(image_df$GPSDateTime)[2]))
```

They seem to be well lined up, considering we started the Arrow GPS up early to let it capture satellites, and I happen to know that I forgot to turn it off until I was in the car ready about to leave, after I had packed everything up, so we will carry on assuming that they are lined up properly for now.

Now that we know that lets make a new column in each dataframe with times that are in the same format as eachother that we will be able to join them on later.

```{r format times}

gps_pnts %<>% 
  mutate(form_time = ymd_hms(time))

image_df %<>% 
  mutate(form_time = ymd_hms(GPSDateTime))

image_df$form_time[1]
gps_pnts$form_time[1]
```

I also happen to know that images were triggered every 2 seconds, and gps points were taken at not so uniform of an interval, so we should see if gps points were captured at even or odd seconds, and then modify the gps_points to fit the seconds of the images.

```{r check evens or odd times}
unique(as.integer(image_df$form_time)%%2==0) #check if there are only odds or evens - TRUE means only odds (modulate by 2)
```

looks like all we have are even times in the image dataframe. So lets round the form_time in the gps_points to the nearest even second so we can more easily join on time.

```{r round gps time}

gps_pnts %<>% 
  mutate(form_time = round_date(form_time, "2 seconds"))

unique(as.integer(gps_pnts$form_time)%%2==0)
```

### Joining Dataframes

Next we need to join the dataframes, so that images can be plotted by the Arrow GPS points. We will lose some of our pictures, as some gps points will be non-existant for a given time, but in these cases we won't lose much as pictures will have been within a few seconds of eachother.

```{r joining dataframes}

combined_GF_df <- gps_pnts %>%
  right_join(image_df, by = c("form_time" = "form_time")) %>% 
  drop_na(lat) %>% 
  select(FileName, lat, lon, ele, form_time, SourceFile)

```

### Add Attributes

Next we just need to add the light indices we computed in the last post.

```{r}
photo_indices <- read.csv2("all_photos_compressed.csv") #file we saved in last post with light indices and image names

combined_GF_df %<>% 
  left_join(photo_indices, by = c("FileName" = "Pic_Name"))
```

Now we have a dataframe with latitude and longitude locations of each picture, and all the computed light indices

```{r map index points, include=FALSE}
pal <- colorNumeric(
  palette = "YlOrRd",
  domain = combined_GF_df$Gap_Frac
)

leaflet(slice(combined_GF_df,which(row_number() %% 2 == 1))) %>% 
  addProviderTiles("Esri.WorldImagery") %>% 
  addCircleMarkers(lng = ~lon, 
                   lat = ~lat,
                   color = ~pal(Gap_Frac),
                   popup = ~paste("Gap Fraction:", Gap_Frac, 
                                  "<br>Effective LAI:", eff_LAI,
                                  "<br>Mean Leaf Angle:", Mean_Leaf_Angle),
                   opacity = .4) %>% 
  addLegend("topright", 
            pal = pal, 
            values = ~Gap_Frac, 
            title = "Gap Fraction")

```

## Interpolation

```{r}

gap_frac_pnts <- SpatialPointsDataFrame(coords = combined_GF_df[,c("lon", 
                                                                   "lat")],
                                        data = combined_GF_df[,c("Gap_Frac",
                                                                 "ele",
                                                                 "eff_LAI",
                                                                 "act_LAI",
                                                                 "Mean_Leaf_Angle",
                                                                 "FileName",
                                                                 "form_time")],
                                        proj4string = CRS("+init=epsg:4326"))

##NOT FUNCTIONAL YET##
#http://jonkatz2.github.io/2017/11/15/interpolating-points-to-raster-in-r#:~:text=Interpolation%20can%20be%20done%20by,creating%20value%2Dgradients%20between%20points.
#https://rdrr.io/github/rspatial/terra/man/interpolate.html
#https://github.com/rspatial/terra/issues/208
gf_pnts <- st_as_sf(combined_GF_df,
                      coords = c("lon", "lat"),
                      crs = "+init=epsg:4326")
bounding_box <- bbox(gf_pnts)

interp_gf_raster <- rast(ymin,
                         res = 10,
                         crs = crs(gf_pnts))

values(interp_gf_raster) <- 1:ncell(interp_gf_raster)

gf_fit <- gstat( formula = Gap_Frac ~ 1,
                 id = "Gap_Frac",
                 data = gf_pnts_2,
                 nmax = 7)

interpolate_gstat <- function(model, x, ...) {
  v <- st_as_sf(x, 
                coords = c("lon", "lat"), 
                crs = crs(model$data[[1]]$data))
  p <- predict(model, v, ...)
  as.data.frame(p)[, 1:2]
}


#https://rspatial.org/spatial-terra/8-rastermanip.html
library(stars)
st_bbox(interp_gf_raster) %>%
  st_as_stars(dx = 1,
              crs = crs(interp_gf_raster)) %>%
  st_crop(st_bbox(interp_gf_raster)) -> grd

grd

plot(idw(Gap_Frac~1, gf_pnts_2, grd))

interp_gf_raster <-  interpolate(object = interp_gf_raster, model = gf_fit, fun = interpolate_gstat, index = 1)
```

## Coming in Part 3

-   Using Uber H3 Hexigons to aggrigate data

-   Using Canopy Height Model to get information

-   Correlating Canopy Height info to Gap Fraction stats

## References
